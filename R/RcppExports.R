# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Double Geometric Distribution
#' 
#' Functions for the Double Geometric distribution.
#' 
#' @param n Number of draws to generate.
#' @param x A vector of points to evaluate.
#' @param q A vector of probabilities to evaluate.
#' @param p probability parameter.
#' @param take_log If \code{TRUE} return the log-density.
#' 
#' @details
#' Here we assume Double Geometric distribution with density
#' \deqn{
#' f(x) = \frac{\rho}{2 - \rho} (1 - \rho)^{|x|}, \quad x \in
#' \{ \ldots, -1, 0, 1, \ldots \}.
#' }
#' 
#' @name Double Geometric
#' @export
d_dgeom <- function(x, p, take_log) {
    .Call(`_DirectSampling_d_dgeom`, x, p, take_log)
}

#' @name Double Geometric
#' @export
p_dgeom <- function(x, p) {
    .Call(`_DirectSampling_p_dgeom`, x, p)
}

#' @name Double Geometric
#' @export
r_dgeom <- function(n, p) {
    .Call(`_DirectSampling_r_dgeom`, n, p)
}

#' @name Double Geometric
#' @export
q_dgeom <- function(q, p) {
    .Call(`_DirectSampling_q_dgeom`, q, p)
}

#' @name Discrete Normal
#' @export
hi_dscnorm <- function(sigma, tol) {
    .Call(`_DirectSampling_hi_dscnorm`, sigma, tol)
}

#' Discrete Normal Distribution
#' 
#' Functions for the Discrete Normal distribution with mean zero.
#' 
#' @param n Number of draws to generate.
#' @param x A vector of points to evaluate.
#' @param q A vector of probabilities to evaluate.
#' @param sigma Standard deviation parameter.
#' @param take_log If \code{TRUE} return the log-density.
#' @param tol Tolerance to truncate to a finite support (see details).
#' @param normalize If \code{TRUE}, normalize the density (approximately).
#' 
#' @details
#' Here we assume Discrete Normal distribution with density
#' \deqn{
#' f(x) \propto \exp( -x^2 / (2 \sigma^2) ), \quad x \in
#' \{ \ldots, -1, 0, 1, \ldots \}.
#' }
#' 
#' The function \code{hi_dscnorm} returns an \eqn{x} so that \eqn{[-x, x]}
#' contains \code{1 - tol} mass of the distribution. This is used to truncate
#' the distribution to have finite support for the simple implementation here.
#'
#' @references
#' Clement L. Canonne, Gautam Kamath, Thomas Steinke (2021), The Discrete
#' Gaussian for Differential Privacy. \url{https://arxiv.org/abs/2004.00010}.
#'
#' @name Discrete Normal
#' @export
d_dscnorm <- function(x, sigma, tol, take_log, normalize) {
    .Call(`_DirectSampling_d_dscnorm`, x, sigma, tol, take_log, normalize)
}

#' @name Discrete Normal
#' @export
p_dscnorm <- function(x, sigma, tol) {
    .Call(`_DirectSampling_p_dscnorm`, x, sigma, tol)
}

#' @name Discrete Normal
#' @export
r_dscnorm <- function(n, sigma) {
    .Call(`_DirectSampling_r_dscnorm`, n, sigma)
}

#' @name Discrete Normal
#' @export
q_dscnorm <- function(q, sigma, tol) {
    .Call(`_DirectSampling_q_dscnorm`, q, sigma, tol)
}

#' Find Interval
#' 
#' @param x A number 
#' @param cutpoints A sorted vector
#' 
#' @details
#' Elements of cutpoints represent endpoints
#' of adjacent intervals \eqn{[c_0,c_1)}, \eqn{[c_1,c_2)} ...,
#' \eqn{[c_{k},c_{k+1})}. Return the index \code{i} such that \code{x} is in 
#' \eqn{[c_i,c_{i+1})}; or return \code{-1} if \eqn{x < c_0}
#' or \code{k+1} if \eqn{x > c_{k+1}}
#'
#' @export
find_interval <- function(x, cutpoints) {
    .Call(`_DirectSampling_find_interval`, x, cutpoints)
}

#' Laplace Distribution
#' 
#' Functions for the Laplace distribution.
#' 
#' @param n Number of draws to generate.
#' @param x A vector of points to evaluate.
#' @param q A vector of probabilities to evaluate.
#' @param mu Location parameter.
#' @param lambda Scale parameter.
#' @param take_log If \code{TRUE} return the log-density.
#' 
#' @details
#' Here we assume Laplace distribution with density
#' \deqn{
#' f(x) = \frac{1}{2\lambda} e^{-|x| / \lambda}.
#' }
#' 
#' @name Laplace
#' @export
d_laplace <- function(x, mu, lambda, take_log) {
    .Call(`_DirectSampling_d_laplace`, x, mu, lambda, take_log)
}

#' @name Laplace
#' @export
p_laplace <- function(x, mu, lambda) {
    .Call(`_DirectSampling_p_laplace`, x, mu, lambda)
}

#' @name Laplace
#' @export
r_laplace <- function(n, mu, lambda) {
    .Call(`_DirectSampling_r_laplace`, n, mu, lambda)
}

#' @name Laplace
#' @export
q_laplace <- function(q, mu, lambda) {
    .Call(`_DirectSampling_q_laplace`, q, mu, lambda)
}

#' Specific Direct Samplers
#' 
#' Functions for some specific direct samplers.
#' 
#' @param n Number of draws to generate.
#' @param z A vector of points to evaluate.
#' @param mu Mean parameter for weight function.
#' @param sigma2 standard deviation parameter for weight function.
#' @param tau Standard deviation parameter for base distribution.
#' @param lambda Scale parameter for base distribution.
#' @param rho Probability parameter for base distribution.
#' @param tol Tolerance for step function approximation in customized sampler.
#' @param N Number of knots to use in approximation for \eqn{p(u)}.
#' @param fill_method Knot selection method for customized direct sampler.
#' Can be either \code{equal_steps} or \code{small_rects}.
#' 
#' @details
#' Implementations for the following direct samplers are provided:
#' \itemize{
#' \item \code{direct_sampler_lognormal_normal}: Lognormal weight function
#' \eqn{w(x \mid \mu, \sigma^2)} and Normal base distribution
#' \eqn{g(x \mid 0, \tau^2)}.
#' 
#' \item \code{direct_sampler_lognormal_dscnorm}: Lognormal weight function
#' \eqn{w(x \mid \mu, \sigma^2)} and Discrete Normal base distribution
#' \eqn{g(x \mid 0, \tau^2)}.
#' 
#' \item \code{direct_sampler_lognormal_laplace}: Lognormal weight function
#' \eqn{w(x \mid \mu, \sigma^2)} and Laplace base distribution
#' \eqn{g(x \mid 0, \lambda)}.
#' 
#' \item \code{direct_sampler_lognormal_dgeom}: Lognormal weight function
#' \eqn{w(x \mid \mu, \sigma^2)} and Double Geometric base distribution
#' \eqn{g(x \mid \rho)}.
#' 
#' \item \code{direct_sampler_normal_laplace}: Normal weight function
#' \eqn{w(x \mid \mu, \sigma^2)} and Laplace base distribution
#' \eqn{g(x \mid 0, \lambda)}.
#' }
#' @name Specific Direct Samplers
#' @export
direct_sampler_lognormal_normal <- function(n, z, mu, sigma2, tau, tol, N, fill_method) {
    .Call(`_DirectSampling_direct_sampler_lognormal_normal`, n, z, mu, sigma2, tau, tol, N, fill_method)
}

#' @name Specific Direct Samplers
#' @export
direct_sampler_lognormal_dscnorm <- function(n, z, mu, sigma2, tau, tol, N, fill_method) {
    .Call(`_DirectSampling_direct_sampler_lognormal_dscnorm`, n, z, mu, sigma2, tau, tol, N, fill_method)
}

#' @name Specific Direct Samplers
#' @export
direct_sampler_lognormal_laplace <- function(n, z, mu, sigma2, lambda, tol, N, fill_method) {
    .Call(`_DirectSampling_direct_sampler_lognormal_laplace`, n, z, mu, sigma2, lambda, tol, N, fill_method)
}

#' @name Specific Direct Samplers
#' @export
direct_sampler_lognormal_dgeom <- function(n, z, mu, sigma2, rho, tol, N, fill_method) {
    .Call(`_DirectSampling_direct_sampler_lognormal_dgeom`, n, z, mu, sigma2, rho, tol, N, fill_method)
}

#' @name Specific Direct Samplers
#' @export
direct_sampler_normal_laplace <- function(n, z, mu, sigma2, lambda, tol, N, fill_method) {
    .Call(`_DirectSampling_direct_sampler_normal_laplace`, n, z, mu, sigma2, lambda, tol, N, fill_method)
}

#' Quantile Function for Discrete Distributions with Finite Support
#' 
#' @param q A vector of quantiles to compute 
#' @param cp Vector of cumulative probabilities of distribution
#' 
#' @return 0-based indices corresponding to the \code{q} quantiles
#' 
#' @details
#' Compute quantiles of a discrete distribution with cumulative probabilities
#' \code{cp(0)}, \code{cp(1)}, ..., \code{cp(k-1)}. Return indices in
#' \eqn{\{ 0, 1, \ldots, k-1 \}} which represent the
#' \code{q} quantiles. The caller can then identify the corresponding value
#' of the distribution (of which this function does not need to be aware).
#' 
#' Uses a bisection search so support relatively large \code{k}.
#' 
#' Note that both \code{q} and \code{cp} may be given on the original
#' probability scale or the log-scale, as long as they are both on the same
#' scale.
#' @examples
#' # Create a simple distribution and compute cumulative probabilities
#' x_seq = 1:10
#' k = length(x_seq)
#' p = rep(1/k, k)
#' cp = cumsum(p)
#' 
#' xx = sample(x = x_seq, size = 100000, replace = TRUE, prob = p)
#' 
#' Compare empirical qq quantiles with q_discrete
#' qq = seq(0, 1, length.out = 100)
#' idx_calc = q_discrete(qq, cp)
#' x_emp = quantile(xx, probs = qq)
#' plot(x_emp, x_seq[idx_calc + 1])
#' 
#' Repeat calculation on the log-scale
#' idx_calc_log = q_discrete(log(qq), log(cp))
#' plot(idx_calc, idx_calc_log)
#' 
#' @export
q_discrete <- function(q, cp) {
    .Call(`_DirectSampling_q_discrete`, q, cp)
}

